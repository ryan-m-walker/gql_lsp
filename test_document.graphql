"
An Agent Definition is the same as a Lindy, it contains information about the agent's behavior
"
type AgentDefinition implements Node {
    conversations(
        after: String
        before: String
        first: Int
        last: Int
    ): AgentDefinitionConversationsConnection!
    hasPremiumActions: Boolean!
    icon: AgentIcon
    id: ID!

    "
    The name of the Agent Definition
    "
    name: String!

    "
    The globally unique ID for the Agent Definition
    "
    nodeId: ID!
    notificationsCount: Int!
    owner: Identity!
}

type AgentDefinitionConversationsConnection {
    edges: [AgentDefinitionConversationsConnectionEdge]!
    pageInfo: PageInfo!
}

type AgentDefinitionConversationsConnectionEdge {
    cursor: String!
    node: Conversation!
}

type AgentFolder {
    "
    The list of Agent Definitions inside this specific folder
    "
    agentDefinitions: [AgentDefinition!]!
    clientId: ID
    id: ID!

    "
    Whether the folder is expanded or not in the UI
    "
    isExpanded: Boolean!

    "
    The name of the folder
    "
    name: String!

    "
    This is the total count of notifications across all agents inside this folder
    "
    notificationsCount: Int!

    "
    This folder's parent folder's client ID. If it is `null` it means this is a root folder. The data structure is flattened, so this is not a recursive field. We use client ID instead of the folder's ID to prevent race conditions on folder creation since the is some latency in folder creation do to the required LLM call
    "
    parentClientId: ID
}

input AgentFolderMovableItemInput {
    agentDefinitionId: ID
    agentFolderClientId: ID
}

type AgentFolders {
    "
    The list of agent folders. This is a flattened data structure, allowing us to have a "infinite" hierarchy of folders. The root folders have a `null` parent ID.
    "
    folders: [AgentFolder!]!

    "
    This is the root "folder", which contains everything that is not inside any specific folder
    "
    root: AgentRootFolder!
}

type AgentIcon {
    color: AgentIconColor!
    name: AgentIconName!
}

enum AgentIconColor {
    Amber
    Blue
    DarkGrey
    Emerald
    Fuchsia
    Green
    Grey
    Indigo
    Lime
    Pink
    Purple
    Red
    Sky
    Slate
    Yellow
}

input AgentIconInput {
    color: AgentIconColor!
    name: AgentIconName!
}

enum AgentIconName {
    AgentIcon1
    AgentIcon2
    AgentIcon3
    AgentIcon4
    AiStarsSparklesIcon
    AiThreeStarsSparklesIcon
    AirplaneIcon
    ArAugmentedRealityCardBoxDVirtualRealityVrIcon
    ArAugmentedRealityDViewCubeIcon
    ArchiveBoxIcon
    ArchiveBoxInboxFileIcon
    ArrowRightCircleIcon
    AtIcon
    AudioMusicPlaylistMusicalNoteIcon
    BagLuggageBuggageIcon
    BagShoppingIcon
    BankIcon
    BatteryChargingIcon
    BedIcon
    BellSimpleIcon
    BirthdayCakeIcon
    BookGuideInfoFaqIcon
    BookIcon
    BookmarkBannerFlagTagIcon
    BotIcon
    BrainAiThinkingIcon
    BrowserWindowAppDesktopIcon
    BrushColorIcon
    BubbleAnnotationMessageIcon
    BucketTrashCanIcon
    BugIssueIcon
    BuildingsIcon
    CalculatorIcon
    CalendarIcon
    ChartStatisticsGraphIcon
    ChatBubbleThoughtMessageIcon
    CheckRadioCircleCheckboxCheckCheckmarkConfirmIcon
    ClockCircleTimeIcon
    CloseXCircleRemoveIcon
    CloudIcon
    CloudySunCloudsIcon
    ColorIcon
    ColorSwatchPaletteColoursIcon
    ColorsPaletteColoursIcon
    CompassBrowserSafariWebInternetIcon
    CookiesIcon
    DashboardFastIcon
    DatabaseIcon
    DeleteRemoveGarbageWasteTrashCanIcon
    DiceFourIcon
    DiskSaveIcon
    EarthGlobeWorldIcon
    EditPencilPencilPenWriteDrawIcon
    EditSmallBoxPencilPenWriteDrawIcon
    EmailEnvelopeIcon
    EmailTriagerIcon
    ErrorWarningAlertIcon
    FileDocumentCloudSyncIcon
    FileDocumentsCopyIcon
    FingerPrintTouchIdIcon
    FireFlameHotHeatIcon
    FolderOpenFileIcon
    GamepadBaseRoundControllsGameJoystickIcon
    GasIcon
    GrowthGrowLeafsIcon
    HandFingerSelectIcon
    HeadphonesSupportIcon
    HeartLikeHealthLifeFavIcon
    HomeOpenHouseIcon
    ImacComputerDeviceIcon
    ImagesPhotosPicturesShotIcon
    InboxArchiveTrayShelfIcon
    InfoCircleTooltipIcon
    KeyIcon
    KeyboardMidiKeysPianoIcon
    KeyboardUpCloseDownOpenArrowIcon
    LabIcon
    LawLegalTermsImprintBalanceIcon
    LayersCopyIcon
    LifeBuoyHelpSupportIcon
    LightBulbIdeaLightIcon
    LinkChainIcon
    LocationExploreCompassIcon
    MacbookLaptopComputerDeviceIcon
    MagicBookMagicianIcon
    MagicHatIcon
    MagicStickIcon
    MeetingSchedulerIcon
    MinusCircleRemoveIcon
    MoonStarNightIcon
    MouseIcon
    NoteCardTextIcon
    NotificationBellActivityIcon
    OpenNoteBookPadIcon
    PauseIcon
    PeopleTogetherUserAvatarGroupIcon
    PhoneDeviceIphoneMobileIcon
    PhoneTelephoneContactIcon
    PictureImageFrameIcon
    PieChartGraphChartStatisticsIcon
    PiggyBankSaveMoneyIcon
    PinLocationBookmarkIcon
    PinLocationIcon
    PinLocationMapIcon
    PlayGoIcon
    PlayIcon
    PlusCircleAddIcon
    PoopSpamIcon
    PostcardCardNewsIcon
    PrinterPrintIcon
    QuestionmarkFaqHelpQuestionaireIcon
    RainbowCloudIcon
    ReadingListGlassesSteveJobsIcon
    ReloadRefreshRepeatIcon
    RocketStartupLaunchIcon
    ScriptFaxReceiptIcon
    SearchMagnifyingGlassIcon
    ServerDataStorageIcon
    ServerStorageDataCoinsMoneyIcon
    SettingsSliderThreeIcon
    ShakaCallMeHangTenIcon
    ShieldCheckSecurityProtectionIcon
    ShieldProtectSecurityCheckIcon
    ShieldSecurityProtectionIcon
    StarFavoriteAwardIcon
    StorageHddSsdIcon
    SunLightModeDayIcon
    SunsetIcon
    TagSaleIcon
    TapeIcon
    TargetArrowGoalAimIcon
    TargetZoomIcon
    ToiletPaperWipeIcon
    TruckDeliveryIcon
    UmbrellaSecurityIcon
    VideoClapperboardIcon
    VoiceIcon
    VolumeFullSpeakerLoudSoundOnMusicIcon
    WebCryptoSpaceIcon
    ZapLightningFlashIcon
}

type AgentRootFolder {
    "
    The list of Agent Definitions that are not inside any folder
    "
    agentDefinitions: [AgentDefinition!]!
}

"
An Agent Template Definition contains information about the agent's behavior and can be added by users from the marketplace
"
type AgentTemplateDefinition implements Node {
    category: TemplateCategory
    icon: AgentIcon
    id: ID!

    "
    The name of the Agent Template Definition
    "
    name: String!

    "
    The globally unique ID for the Agent Template Definition
    "
    nodeId: ID!

    "
    The subtitle of the Agent Template Definition
    "
    subtitle: String
}

type Auth implements Node {
    accountId: ID!
    displayName: String!

    "
    Schema for Custom Auth fields
    "
    fields: JSONObject
    id: ID!

    "
    True if this auth is valid
    "
    isConnected: Boolean!
    label: String!
    method: String!

    "
    The globally unique ID for the user used by Relay
    "
    nodeId: ID!
    provider: String!
    redirectUri: URL
    scopes: [String!]

    "
    The lindies that use this auth
    "
    usedBy: [AgentDefinition!]
}

enum AuthMethod {
    Custom
    OAuth
    Token
}

type BadRequestError implements Error {
    message: String!
}

type BaseError implements Error {
    message: String!
}

"
BigNumber scalar type
"
scalar BigNumber

enum BillingVersion {
    V2
    V3
}

input CancelIdentityEmailUpdateInput {
    id: ID!
}

type CancelIdentityEmailUpdateOutput {
    identity: Identity!
}

type Conversation implements Node {
    blocks(
        after: String
        before: String
        first: Int
        last: Int
    ): ConversationBlocksConnection!
    id: ID!

    "
    The globally unique ID for the Conversation, this can be used to retrieve the Conversation using the node resolvers
    "
    nodeId: ID!
    owner: Identity!
    title: String
}

type ConversationBlock implements Node {
    content: ConversationBlockContentInterface!
    id: ID!

    "
    The globally unique ID for the Block, this can be used to retrieve the Block using the node resolvers
    "
    nodeId: ID!
    owner: Identity!
}

type ConversationBlockContentBase implements ConversationBlockContentInterface {
    text: String!
    type: ConversationBlockType!
}

interface ConversationBlockContentInterface {
    text: String!
    type: ConversationBlockType!
}

enum ConversationBlockType {
    ACTION_CALL
    ACTION_RESULT
    ANSWER
    CODE
    CODE_ERROR
    CODE_RESULT
    CODE_VARIABLES
    DECLARATION
    DEPRECATED_CODE
    EXAMPLE
    HINT
    INTERNAL_ACTION_CHECKPOINT
    INTERNAL_ACTION_INPUT_SUBMISSION
    INTERNAL_ACTION_NEEDED_API_TOKEN_AUTH
    INTERNAL_ACTION_NEEDED_CREDITS
    INTERNAL_ACTION_NEEDED_CUSTOM_AUTH
    INTERNAL_ACTION_NEEDED_CUSTOM_OAUTH2
    INTERNAL_ACTION_NEEDED_OAUTH2_AUTH
    INTERNAL_ACTION_NEEDED_ONBOARDING
    INTERNAL_ACTION_NEEDED_PAUSED
    INTERNAL_CONVERSATION_PARAMS
    INTERNAL_EXECUTION_CHECKPOINT
    INTERNAL_EXECUTION_DETAILS
    INTERNAL_EXECUTION_TRACE
    INTERNAL_GRAPH_TRAVERSAL
    INTERNAL_GUIDELINES_UPDATED
    INTERNAL_INCOMPLETE_BLOCK
    INTERNAL_POSTHOG_SESSION_DETAILS
    INTERNAL_STREAMING
    KNOWLEDGE_BASE_SEARCH_RESULT
    MEDIA
    MESSAGE_RECEIVED
    MESSAGE_SENT
    SYSTEM_INSTRUCTION
    SYSTEM_PRUNING_HINT
    TALK
    THOUGHT
    TO_DELETE_MEMORY
    TO_DELETE_USER
}

type ConversationBlocksConnection {
    edges: [ConversationBlocksConnectionEdge]!
    pageInfo: PageInfo!
}

type ConversationBlocksConnectionEdge {
    cursor: String!
    node: ConversationBlock!
}

input CreateAgentFolderInput {
    "
    You can add agent definitions inside this folder while creating it to avoid having to call a separate mutation to do this
    "
    agentDefinitionIds: [ID!]

    "
    A unique identifier for this folder that is generated by the client. This will link child folders to parent folders and is done with client ID rather than folder ID to prevent race conditions since folder creation has a significant delay due to the LLM calls.
    "
    clientId: ID!

    "
    This is the ID of the owner of this resource (Identity ID)
    "
    id: ID!

    "
    The name of the folder, this is optional, as it will be automatically generated from the list of agent definitions passed. The mutation will fail if this is not provided and the list of agents is empty.
    "
    name: String

    "
    The client ID of the folder that this folder may be nested in. If null the folder will be at the root
    "
    parentClientId: ID
}

type CreateAgentFolderOutput {
    agentFolder: AgentFolder!
    owner: Identity!
}

input CreateStateGraphTestRunInput {
    "
    This is the ID of the agent definition that is being tested
    "
    agentDefinitionId: ID!

    "
    This list of edges of the state graph
    "
    edges: [JSONObject!]!

    "
    This is the ID of the owner of this resource (Identity ID)
    "
    id: ID!

    "
    The list of nodes of the state graph
    "
    nodes: [JSONObject!]!
}

type CreateStateGraphTestRunOutput {
    stateGraphTestRun: StateGraphTestRun!
}

type CreditsInfo {
    additionalCredits: Int!
    consumed: Int!
    creditAllocation: Int!
    percentConsumed: Float!
}

"
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"
scalar Date

input DeleteAgentFolderInput {
    agentFolderId: ID!

    "
    This is the ID of the owner of the agent folder
    "
    id: ID!
}

type DeleteAgentFolderOutput {
    owner: Identity!
}

input DeleteAuthInput {
    id: ID!
}

type DeleteAuthOutput {
    "
    The ID of the deleted auth
    "
    deletedAuthId: ID!
}

input DeleteIdentityInput {
    id: ID!
}

type DeleteIdentityOutput {
    identity: Identity!
}

interface Error {
    message: String!
}

input GenerateRedirectUriInput {
    extraState: JSON
    id: ID!
    provider: String!
    scopes: [String!]!
}

type GenerateRedirectUriOutput {
    redirectUri: String!
}

type Identity implements Node {
    "
    This represents the user's agent file structure.
    "
    agentFolders: AgentFolders!
    auth(
        "
        Authentication method
        "
        method: AuthMethod

        "
        Authentication provider
        "
        provider: String
    ): [Auth!]!

    "
    The avatar URL of the user
    "
    avatar: Image
    billingInfo: SubscriptionInfo

    "
    The date the user account was created
    "
    createdAt: Date!
    email: String!
    id: ID!

    "
    True if and only if this user is a Lindy admin
    "
    isAdmin: Boolean!

    "
    Whether this user is considered a medical scribe customer, determined by the occupation associated with this user.
    "
    isMedicalScribe: Boolean!
    name: String!

    "
    The globally unique ID for the user used by Relay
    "
    nodeId: ID!
    owner: Identity!

    "
    If user has requested an email address change, this field contains the new unconfirmed email address. It is cleared by setting to null/empty string once user verifies the new email address through the confirmation link sent to that address.
    "
    pendingEmail: String
    phone: PhoneNumber
}

type Image {
    "
    The height of the image in pixels
    "
    heightPx: Int

    "
    The URL of the image
    "
    url: String!

    "
    The width of the image in pixels
    "
    widthPx: Int
}

"
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"
scalar JSON

"
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"
scalar JSONObject

"
Enumeration of all available tools
"
enum LindyTool {
    ActionNetwork
    ActiveCampaign
    Adalo
    Affinity
    AgileCrm
    Airtable
    AmazonS3
    ApiTemplateIo
    Apitable
    Approval
    Asana
    Automizy
    Autopilot
    AwsCertificateManager
    AwsComprehend
    AwsDynamoDB
    AwsElb
    AwsRekognition
    AwsS3
    AwsSes
    AwsTranscribe
    BambooHr
    Bannerbear
    Baserow
    Beeminder
    Binance
    Bitly
    Bitwarden
    Box
    Brevo
    BrowseAI
    Browser
    Bubble
    CalCom
    Calendar
    CalendarEvent
    Calendly
    Certopus
    Channels
    Chargebee
    Chatbots
    CircleCi
    CiscoWebex
    CitrixAdc
    Clarifai
    Clearbit
    Clickup
    Clockify
    Clockodo
    Cloudflare
    Cockpit
    Coda
    CoinGecko
    Contentful
    Contiguity
    ConvertKit
    Copper
    Cortex
    CrowdDev
    Csv
    CustomerIo
    DataMapper
    DateHelper
    Debug
    DebugInstance
    DeepL
    Deepl
    Delay
    Demio
    Dhl
    Directory
    DirectoryEntity
    Discord
    Discourse
    Disqus
    DocumentReader
    DraftEmail
    Drift
    Drip
    Dropbox
    Dropcontact
    ERPNext
    Egoi
    ElasticSecurity
    Elasticsearch
    EmailSend
    Emelia
    FacebookLeads
    FacebookPages
    Figma
    FileEntity
    FileHandler
    FileHelper
    Flow
    Freshdesk
    Freshsales
    Freshservice
    FreshworksCrm
    GSuiteAdmin
    GcloudPubsub
    GetResponse
    Ghost
    Ghostcms
    GitHub
    GitHubPullRequest
    GitRepository
    Github
    Gitlab
    Gmail
    GmailMessage
    GoToWebinar
    Google
    GoogleAds
    GoogleAnalytics
    GoogleBigQuery
    GoogleBooks
    GoogleChat
    GoogleCloudNaturalLanguage
    GoogleCloudStorage
    GoogleContacts
    GoogleDocs
    GoogleDrive
    GoogleFirebaseCloudFirestore
    GoogleForms
    GoogleMyBusiness
    GooglePeopleContacts
    GoogleSearch
    GoogleSheets
    GoogleSlides
    GoogleTasks
    GoogleTranslate
    Gotify
    Grafana
    Gravityforms
    HackerNews
    HaloPSA
    Harvest
    HelpScout
    HighLevel
    HomeAssistant
    Http
    Hubspot
    HumanticAi
    Imap
    Inbox
    InstagramBusiness
    Intercom
    InvoiceNinja
    ItemLists
    Iterable
    Jenkins
    Jira
    Jotform
    Keap
    Kimai
    Kitemaker
    KizeoForms
    KnowledgeBase
    KoBoToolbox
    Lemlist
    Lindy
    LindyAttachment
    LindyDatabaseExperimental
    LindyEmbed
    LindyMail
    LindyMailMessage
    LindyMedia
    LindyMeeting
    LindyMessenger
    LindyWebhook
    Linear
    LinkedIn
    ListSearch
    Llmrails
    Localai
    LoneScale
    Magento2
    Mailcheck
    Mailchimp
    MailerLite
    Mandrill
    Marketstack
    Mastodon
    MathHelper
    Matrix
    Mattermost
    Mautic
    Medium
    MessageBird
    Metabase
    MicrosoftDynamicsCrm
    MicrosoftExcel
    MicrosoftExcel365
    MicrosoftGraphSecurity
    MicrosoftOneDrive
    MicrosoftOnedrive
    MicrosoftOutlook
    MicrosoftOutlookMessage
    MicrosoftTeams
    MicrosoftToDo
    Mindee
    Misp
    Mocean
    Monday
    MondayCom
    MonicaCrm
    Msg91
    Mysql
    Nasa
    NaturalLanguage
    Netlify
    NextCloud
    Nifty
    NocoDB
    Notion
    Npm
    Ntfy
    Odoo
    Onboarding
    OnboardingV3
    OneSimpleApi
    Onfleet
    OpenAI
    OpenRouter
    Orbit
    Oura
    Paddle
    PagerDuty
    Pastebin
    Pastefy
    PayPal
    PeopleDataLabs
    Phantombuster
    PhilipsHue
    Pipedrive
    Plivo
    PostBin
    PostHog
    Postgres
    Preferences
    ProfitWell
    Pushbullet
    Pushcut
    Pushover
    Qdrant
    QuickBase
    QuickBooks
    Raindrop
    Resend
    Rocketchat
    Rss
    Rundeck
    S3
    Saastic
    Salesforce
    Salesmate
    Schedule
    ScriptTool
    SeaTable
    SecurityScorecard
    Segment
    SendGrid
    SendToChannel
    Sendfox
    Sendgrid
    Sendinblue
    Sendy
    SentryIo
    ServiceNow
    Sftp
    Shopify
    Signl4
    Simplepdf
    Slack
    SlackMessage
    Sms77
    Smtp
    Soap
    Splunk
    Spontit
    Spotify
    Square
    Ssh
    StabilityAi
    State
    Store
    Storyblok
    Strapi
    Strava
    Stripe
    Supabase
    Surveymonkey
    SyncroMsp
    Tags
    Taiga
    Talkable
    Tally
    Tapfiliate
    Task
    Telegram
    TelegramBot
    Test
    TextGeneration
    TextHelper
    TheHiveProject
    Tidycal
    Timer
    Todoist
    TravisCi
    Trello
    Twake
    Twilio
    Twist
    Twitter
    Typeform
    UI
    UnleashedSoftware
    Uplead
    UptimeRobot
    UrlScanIo
    VenafiTlsProtectCloud
    VenafiTlsProtectDatacenter
    Vero
    Vonage
    Vtex
    Wandb
    Webflow
    Wekan
    WhatsApp
    Wise
    WooCommerce
    Wordpress
    Xero
    Xml
    YouTube
    Yourls
    Zammad
    Zendesk
    ZohoCrm
    ZohoInvoice
    Zoom
    Zulip
}

input MoveItemsToAgentFolderInput {
    "
    Setting this to null means "Move this to the root, so it has no parent folder".
    "
    agentFolderClientId: ID

    "
    The ID of the identity whose folder items are being moved
    "
    id: ID!
    items: [AgentFolderMovableItemInput!]!
}

type MoveItemsToAgentFolderOutput {
    owner: Identity!
}

type Mutation {
    cancelIdentityEmailUpdate(
        input: CancelIdentityEmailUpdateInput!
    ): MutationCancelIdentityEmailUpdateResult!
    createAgentFolder(
        input: CreateAgentFolderInput!
    ): MutationCreateAgentFolderResult!
    createStateGraphTestRun(
        input: CreateStateGraphTestRunInput!
    ): MutationCreateStateGraphTestRunResult!
    deleteAgentFolder(
        input: DeleteAgentFolderInput!
    ): MutationDeleteAgentFolderResult!
    deleteAuth(input: DeleteAuthInput!): MutationDeleteAuthResult!
    deleteIdentity(input: DeleteIdentityInput!): MutationDeleteIdentityResult!
    generateRedirectUri(
        input: GenerateRedirectUriInput!
    ): MutationGenerateRedirectUriResult!
    moveItemsToAgentFolder(
        input: MoveItemsToAgentFolderInput!
    ): MutationMoveItemsToAgentFolderResult!
    requestIdentityEmailUpdate(
        input: RequestIdentityEmailUpdateInput!
    ): MutationRequestIdentityEmailUpdateResult!
    resendIdentityEmailUpdate(
        input: ResendIdentityEmailUpdateInput!
    ): MutationResendIdentityEmailUpdateResult!
    updateAgent(input: UpdateAgentInput!): MutationUpdateAgentResult!
    updateAgentFolder(
        input: UpdateAgentFolderInput!
    ): MutationUpdateAgentFolderResult!
    updateIdentity(input: UpdateIdentityInput!): MutationUpdateIdentityResult!
    updateIdentityAvatar(
        input: UpdateIdentityAvatarInput!
    ): MutationUpdateIdentityAvatarResult!
    updateIdentityPassword(
        input: UpdateIdentityPasswordInput!
    ): MutationUpdateIdentityPasswordResult!
}

union MutationCancelIdentityEmailUpdateResult =
      BaseError
    | MutationCancelIdentityEmailUpdateSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationCancelIdentityEmailUpdateSuccess {
    data: CancelIdentityEmailUpdateOutput!
}

union MutationCreateAgentFolderResult =
      BaseError
    | MutationCreateAgentFolderSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationCreateAgentFolderSuccess {
    data: CreateAgentFolderOutput!
}

union MutationCreateStateGraphTestRunResult =
      BaseError
    | MutationCreateStateGraphTestRunSuccess
    | NotFoundError
    | StateGraphValidationError
    | UnauthorizedError
    | ValidationError

type MutationCreateStateGraphTestRunSuccess {
    data: CreateStateGraphTestRunOutput!
}

union MutationDeleteAgentFolderResult =
      BaseError
    | MutationDeleteAgentFolderSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationDeleteAgentFolderSuccess {
    data: DeleteAgentFolderOutput!
}

union MutationDeleteAuthResult =
      BaseError
    | MutationDeleteAuthSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationDeleteAuthSuccess {
    data: DeleteAuthOutput!
}

union MutationDeleteIdentityResult =
      BaseError
    | MutationDeleteIdentitySuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationDeleteIdentitySuccess {
    data: DeleteIdentityOutput!
}

union MutationGenerateRedirectUriResult =
      BaseError
    | MutationGenerateRedirectUriSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationGenerateRedirectUriSuccess {
    data: GenerateRedirectUriOutput!
}

union MutationMoveItemsToAgentFolderResult =
      BaseError
    | MutationMoveItemsToAgentFolderSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationMoveItemsToAgentFolderSuccess {
    data: MoveItemsToAgentFolderOutput!
}

union MutationRequestIdentityEmailUpdateResult =
      BaseError
    | MutationRequestIdentityEmailUpdateSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationRequestIdentityEmailUpdateSuccess {
    data: RequestIdentityEmailUpdateOutput!
}

union MutationResendIdentityEmailUpdateResult =
      BaseError
    | MutationResendIdentityEmailUpdateSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationResendIdentityEmailUpdateSuccess {
    data: ResendIdentityEmailUpdateOutput!
}

union MutationUpdateAgentFolderResult =
      BaseError
    | MutationUpdateAgentFolderSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateAgentFolderSuccess {
    data: UpdateAgentFolderOutput!
}

union MutationUpdateAgentResult =
      BaseError
    | MutationUpdateAgentSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateAgentSuccess {
    data: UpdateAgentOutput!
}

union MutationUpdateIdentityAvatarResult =
      BaseError
    | MutationUpdateIdentityAvatarSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateIdentityAvatarSuccess {
    data: UpdateIdentityAvatarOutput!
}

union MutationUpdateIdentityPasswordResult =
      BaseError
    | MutationUpdateIdentityPasswordSuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateIdentityPasswordSuccess {
    data: UpdateIdentityPasswordOutput!
}

union MutationUpdateIdentityResult =
      BaseError
    | MutationUpdateIdentitySuccess
    | NotFoundError
    | UnauthorizedError
    | ValidationError

type MutationUpdateIdentitySuccess {
    data: UpdateIdentityOutput!
}

interface Node {
    nodeId: ID!
}

type NotFoundError implements Error {
    entity: String!
    message: String!
}

type ObservableChannelMetadata {
    immediateEdgeLabel: String!
    observableEdgeLabel: String!
    statefulToolKey: String!
}

type PageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type PaymentInfo {
    brand: String!
    expMonth: Int!
    expYear: Int!
    last4: String!
}

"
A field whose value conforms to the standard E.164 format as specified in: https://en.wikipedia.org/wiki/E.164. Basically this is +17895551234.
"
scalar PhoneNumber

enum PlanCadence {
    Annual
    Monthly
    Yearly
}

enum PlanType {
    FreeMonthly
    MedicalScribeTrial
    ProMonthly
    Trial
}

type Query {
    "
    This is only used for testing the scalars provided by this schema.
    "
    _scalars: ScalarsTest!
    me: Identity!
    node(id: ID!): Node
    nodes(ids: [ID!]!): [Node]!

    "
    Returns agent definitions grouped by the provided categories
    "
    templatesByCategory(
        categories: [TemplateCategory!]
    ): [TemplatesByCategoryOutput!]!

    "
    Retrieves a paginated list of tools available for the authenticated user.
    "
    tools(
        after: String
        before: String
        first: Int
        last: Int
    ): QueryToolsConnection!
}

type QueryToolsConnection {
    edges: [QueryToolsConnectionEdge]!
    pageInfo: PageInfo!
}

type QueryToolsConnectionEdge {
    cursor: String!
    node: Tool!
}

input RequestIdentityEmailUpdateInput {
    id: ID!
    newEmail: String!
    password: String!
    previousEmail: String!
}

type RequestIdentityEmailUpdateOutput {
    identity: Identity!
}

input ResendIdentityEmailUpdateInput {
    email: String!
    id: ID!
    name: String!
}

type ResendIdentityEmailUpdateOutput {
    identity: Identity!
}

type ScalarsTest {
    jsonObject: JSONObject
    jsonObjectList: [JSONObject!]!
}

enum SpeechToTextTerms {
    English
    MultiLingual
}

enum StateGraphEntityType {
    Edges
    Graph
    Nodes
}

enum StateGraphIssueType {
    Error
    Warning
}

type StateGraphTestRun implements Node {
    greetingMessage: String
    id: ID!

    "
    The globally unique ID used by Relay
    "
    nodeId: ID!
    owner: Identity!
}

type StateGraphValidationError implements Error {
    issues: [StateGraphValidationIssue!]!
    message: String!
}

type StateGraphValidationIssue {
    entityType: StateGraphEntityType!
    id: ID!
    label: String
    message: String!
    type: StateGraphIssueType!
}

type SubscriptionFeatures {
    arePremiumActionsEnabled: Boolean!
    arePremiumFeaturesEnabled: Boolean!
    isEligibleForFreePlan: Boolean!
    speechToText: SpeechToTextTerms
    trialCreditUsageType: TrialCreditUsageType
}

type SubscriptionInfo {
    billingPeriodEndsAt: Date
    billingPeriodStartAt: Date
    billingVersion: BillingVersion!
    creditsInfo: CreditsInfo!
    features: SubscriptionFeatures
    id: ID!
    paymentInfo: PaymentInfo

    "
    The ID of the plan in Lindy
    "
    planId: ID!

    "
    The portal/stripe URL
    "
    portal: URL
    subscriptionExpiresAt: Date

    "
    The subscription plan
    "
    subscriptionPlan: SubscriptionPlan!
    subscriptionStartAt: Date
    trialInfo: TrialInfo

    "
    The upcoming subscription plan if available
    "
    upcomingPlan: UpcomingPlan
}

type SubscriptionPlan {
    cadence: PlanCadence!
    creditAllocation: Int!
    id: ID!
    name: String!
    planType: PlanType
    price: BigNumber!
}

enum TemplateCategory {
    PersonalAssistant
    SalesMarketing
    Scribe
    Support
}

type TemplatesByCategoryOutput {
    category: TemplateCategory!
    templates: [AgentTemplateDefinition!]!
}

type Tool implements Node {
    actions(
        after: String
        before: String
        first: Int
        last: Int
    ): ToolActionsConnection!
    description: String!
    displayName: String!
    isPopular: Boolean!
    nodeId: ID!
    tool: String!
    triggers(
        after: String
        before: String
        first: Int
        last: Int
    ): ToolTriggersConnection!
}

type ToolAction implements Node {
    dependencies: [ToolAction!]!

    "
    The description of a tool, to be shown in the frontend
    "
    description: String!

    "
    The display name of a tool, to be shown in the frontend.
    "
    displayName: String!
    inputSchema: JSON
    key: String!
    nodeId: ID!
    outputSchema: JSON
    signature: ToolActionSignature!
    tool: LindyTool
}

type ToolActionSignature {
    action: String!
    signature: [String!]!
    tool: LindyTool!
}

type ToolActionsConnection {
    edges: [ToolActionsConnectionEdge]!
    pageInfo: PageInfo!
}

type ToolActionsConnectionEdge {
    cursor: String!
    node: ToolAction!
}

type ToolTriggers {
    "
    The description of a trigger, to be shown in the frontend
    "
    description: String

    "
    The display name of a trigger, to be shown in the frontend
    "
    displayName: String!
    fields: [TriggerFieldForm!]!
    fieldsValues: JSON!

    "
    Allows trigger configurations to be published with marketplace templates.
    "
    hasPublishableConfig: Boolean!
    id: ID!
    isAuthorized: Boolean
    isConfigured: Boolean!
    isEnabled: Boolean!

    "
    Marks this trigger as high throughput, allowing it to run more frequently and be identified as expensive in the UI.
    "
    isHighThroughput: Boolean!
    name: String!
    tool: LindyTool!
}

type ToolTriggersConnection {
    edges: [ToolTriggersConnectionEdge]!
    pageInfo: PageInfo!
}

type ToolTriggersConnectionEdge {
    cursor: String!
    node: ToolTriggers!
}

enum TrialCreditUsageType {
    Restricted
    Unrestricted
}

type TrialInfo {
    expiresAt: Date!
}

type TriggerFieldForm {
    aliases: JSON
    canBeSharedWithTemplate: Boolean
    defaultValue: JSON
    description: String
    fields: [String!]
    id: String!
    isRequired: Boolean!
    label: String!
    max: Float
    min: Float
    options: [TriggerFieldFormOption!]
    placeholder: String
    step: Float
    tooltip: String
    type: String!
}

type TriggerFieldFormOption {
    id: String!
    label: String!
    value: String!
}

"
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"
scalar URL

type UnauthorizedError implements Error {
    message: String!
}

type UpcomingPlan {
    startDate: Date!
    subscriptionPlan: SubscriptionPlan!
}

input UpdateAgentFolderInput {
    "
    This is the ID of the agent folder
    "
    agentFolderId: ID!

    "
    This is the ID of the owner of the agent folder
    "
    id: ID!
    isExpanded: Boolean
    name: String
}

type UpdateAgentFolderOutput {
    agentFolder: AgentFolder!
    owner: Identity!
}

input UpdateAgentInput {
    "
    This is the ID of the agent
    "
    agentDefinitionId: ID!
    icon: AgentIconInput

    "
    This is the ID of the owner of the agent
    "
    id: ID!
    name: String
}

type UpdateAgentOutput {
    agent: AgentDefinition!
}

input UpdateIdentityAvatarInput {
    "
    The upload data and file metadata. If null the user's avatar will be deleted
    "
    file: UploadAvatarFileInput
    id: ID!
}

type UpdateIdentityAvatarOutput {
    identity: Identity!
}

input UpdateIdentityInput {
    id: ID!
    name: String
}

type UpdateIdentityOutput {
    identity: Identity!
}

input UpdateIdentityPasswordInput {
    email: String!
    newPassword: String!
    previousPassword: String!
}

type UpdateIdentityPasswordOutput {
    identity: Identity!
}

"
The `Upload` scalar type represents a file upload.
"
scalar Upload

input UploadAvatarFileInput {
    heightPx: Int!
    upload: Upload!
    widthPx: Int!
}

type ValidationError implements Error {
    fieldErrors: [ValidationFieldError!]!
    message: String!
}

type ValidationFieldError {
    message: String!
    path: [String!]!
}
